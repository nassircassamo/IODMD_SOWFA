function [CostFunction,Vperp,GRAD]=lpvfun(xout,th,d,ind,u,y,p,CF)
%LPVFUN    Computes cost function, gradient and projection for lpvopt.
%          Auxiliary function used by lpvopt.
%    [COSTFUN,VPERP,GRAD]=LPVFUN(TH,THO,DIM,IND,U,Y,P,CF)
%    Computes cost function COSTFUN, gradient GRAD and projection
%    VPERP for LPVOPT. TH is the parameter vector generated by
%    LPV2PAR. THO contains the initial and thus also the constant
%    parameters. DIM contains the dimensions of x(k), u(k), y(k)
%    and p(k). IND contains the indices for the parameters that
%    are optimized. U is an N-by-m matrix containing
%    the m inputs, P is an N-by-s matrix containing the s time varying
%    parameters, Y is an N-by-l matrix containing the l outputs.
%    If CF equals 2, only the CostFunction is evaluated.
%    If CF equals 1, the Costfunction and Vperp are computed.
%    If CF equals 0, the Costfunction, Vperp and the gradient are computed.

% Written by Vincent Verdult, February 2001.

% convert optimized parameters xout to full parameter vector
% including the constant parameters
th(ind)=xout;
[A,B,C,D]=par2lpv(th,d);
Vperp=[];
GRAD=[];

% Compute CostFunction
n=d(1);
m=d(2);
l=d(3);
s=d(4);
N=size(u,1);
x=lpvitr(A,B,p,u,[],zeros(n,1));
pu=zeros(N,s*m);
px=zeros(N,s*n);
for i = 1:s
    pu(:,(i-1)*m+1:i*m) = u.*(p(:,i)*ones(1,m));
end
for i = 1:s;
    px(:,(i-1)*n+1:i*n) = x.*(p(:,i)*ones(1,n));
end
ye=[x, px]*C'+[u, pu]*D';

CostFunction=(y(:)-ye(:))/N;

% if CF equals 2, only the CostFunction is evaluated
% if CF equals 1, the Costfunction and Vperp are computed
% if CF equals 0, the Costfunction, Vperp and the gradient are computed

if (CF==0 || CF==1)
    Npar=size(xout,1);  % Number of parameters
    N=size(y,1);      % Number of data points
    m=d(2);
    l=d(3);
    s=d(4);
    % Compute projection
    phik=zeros(n*n,(n+l)*(n+m)*(s+1));
    for k=1:s+1
        pik=eye(n,n);
        if k>1
            pik= horzcat(zeros(n,(k-1)*n), pik);
        end
        if k<s+1;
            pik= horzcat(pik, zeros(n,(s+1-k)*n));
        end
        phik=phik+kron([pik,zeros(n,m*(s+1))],pik*[A;C]');
    end
    phik=phik-kron([A,B],[eye(n,n),zeros(n,l)]);
    
    % correction for constant parameters
    phik=phik(:,ind);
    [U,S,V]=svd(phik,0);
    rk=rank(S);
    if rk<n*n
        error('Matrix Phi_k is rank deficient')
    end
    Vperp=V(:,rk+1:end);
end

if CF==0
    % Compute gradient
    GRAD=zeros(Npar,N*l);
    dth=zeros((n+l)*(n+m)*(s+1),1);
    X0=lpvitr(A,zeros(n,s+1),p,zeros(N,1),[],zeros(n,1));
    pX0=zeros(N,s*n);
    for i = 1:s
        pX0(:,(i-1)*n+1:i*n) = X0.*(p(:,i)*ones(1,n));
    end
    for k=1:Npar;
        dth(ind(k))=1;
        [dA,dB,dC,dD]=par2lpv(dth,d);
        dth(ind(k))=0;
        % Build B matrix for extended input
        if sum(sum(abs(dA)))==0 && sum(sum(abs(dB)))==0
            X=X0;
            pX=pX0;
        else
            MB=zeros(n,(n+m)*(s+1));
            for i=1:s+1
                MB(:,(i-1)*(n+m)+1:i*(n+m))=[dA(:,(i-1)*n+1:i*n),dB(:,(i-1)*m+1:i*m)];
            end
            X=lpvitr(A,MB,p,[x,u],[],zeros(n,1));
            pX=zeros(N,s*n);
            for i = 1:s
                pX(:,(i-1)*n+1:i*n) = X.*(p(:,i)*ones(1,n));
            end
        end
        YX=[X, pX]*C';
        if sum(sum(abs(dC)))==0 && sum(sum(abs(dD)))==0
            Y=YX;
        elseif sum(sum(abs(dC)))==0
            Y=YX+[u, pu]*dD';
        elseif sum(sum(abs(dD)))==0
            Y=YX+[x, px]*dC';
        else
            Y=YX+[x, px]*dC'+[u, pu]*dD';
        end
        GRAD(k,:)=-Y(:)'/N;
    end
end






